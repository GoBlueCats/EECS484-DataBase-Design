        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base
        -:    0:Graph:LogMgr.gcno
        -:    0:Data:LogMgr.gcda
        -:    0:Runs:6
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4://                     The LLVM Compiler Infrastructure
        -:    5://
        -:    6:// This file is dual licensed under the MIT and the University of Illinois Open
        -:    7:// Source Licenses. See LICENSE.TXT for details.
        -:    8://
        -:    9://===----------------------------------------------------------------------===//
        -:   10:
        -:   11:#ifndef _LIBCPP_FUNCTIONAL_BASE
        -:   12:#define _LIBCPP_FUNCTIONAL_BASE
        -:   13:
        -:   14:#include <__config>
        -:   15:#include <type_traits>
        -:   16:#include <typeinfo>
        -:   17:#include <exception>
        -:   18:#include <new>
        -:   19:
        -:   20:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:   21:#pragma GCC system_header
        -:   22:#endif
        -:   23:
        -:   24:_LIBCPP_BEGIN_NAMESPACE_STD
        -:   25:
        -:   26:template <class _Arg, class _Result>
        -:   27:struct _LIBCPP_TYPE_VIS_ONLY unary_function
        -:   28:{
        -:   29:    typedef _Arg    argument_type;
        -:   30:    typedef _Result result_type;
        -:   31:};
        -:   32:
        -:   33:template <class _Arg1, class _Arg2, class _Result>
        -:   34:struct _LIBCPP_TYPE_VIS_ONLY binary_function
        -:   35:{
        -:   36:    typedef _Arg1   first_argument_type;
        -:   37:    typedef _Arg2   second_argument_type;
        -:   38:    typedef _Result result_type;
        -:   39:};
        -:   40:
        -:   41:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;
        -:   42:
        -:   43:template <class _Tp>
        -:   44:struct __has_result_type
        -:   45:{
        -:   46:private:
        -:   47:    struct __two {char __lx; char __lxx;};
        -:   48:    template <class _Up> static __two __test(...);
        -:   49:    template <class _Up> static char __test(typename _Up::result_type* = 0);
        -:   50:public:
        -:   51:    static const bool value = sizeof(__test<_Tp>(0)) == 1;
        -:   52:};
        -:   53:
        -:   54:#if _LIBCPP_STD_VER > 11
        -:   55:template <class _Tp = void>
        -:   56:#else
        -:   57:template <class _Tp>
        -:   58:#endif
        -:   59:struct _LIBCPP_TYPE_VIS_ONLY less : binary_function<_Tp, _Tp, bool>
        -:   60:{
        -:   61:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 
        -:   62:    bool operator()(const _Tp& __x, const _Tp& __y) const
      965:   63:        {return __x < __y;}
        -:   64:};
        -:   65:
        -:   66:#if _LIBCPP_STD_VER > 11
        -:   67:template <>
        -:   68:struct _LIBCPP_TYPE_VIS_ONLY less<void>
        -:   69:{
        -:   70:    template <class _T1, class _T2> 
        -:   71:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:   72:    auto operator()(_T1&& __t, _T2&& __u) const
        -:   73:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u)))
        -:   74:    -> decltype        (_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u))
        -:   75:        { return        _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }
        -:   76:    typedef void is_transparent;
        -:   77:};
        -:   78:#endif
        -:   79:
        -:   80:// addressof
        -:   81:
        -:   82:template <class _Tp>
        -:   83:inline _LIBCPP_INLINE_VISIBILITY
        -:   84:_Tp*
        -:   85:addressof(_Tp& __x) _NOEXCEPT
        -:   86:{
     1016:   87:    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);
        -:   88:}
        -:   89:
        -:   90:#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)
        -:   91:// Objective-C++ Automatic Reference Counting uses qualified pointers
        -:   92:// that require special addressof() signatures. When
        -:   93:// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler
        -:   94:// itself is providing these definitions. Otherwise, we provide them.
        -:   95:template <class _Tp>
        -:   96:inline _LIBCPP_INLINE_VISIBILITY
        -:   97:__strong _Tp*
        -:   98:addressof(__strong _Tp& __x) _NOEXCEPT
        -:   99:{
        -:  100:  return &__x;
        -:  101:}
        -:  102:
        -:  103:#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK
        -:  104:template <class _Tp>
        -:  105:inline _LIBCPP_INLINE_VISIBILITY
        -:  106:__weak _Tp*
        -:  107:addressof(__weak _Tp& __x) _NOEXCEPT
        -:  108:{
        -:  109:  return &__x;
        -:  110:}
        -:  111:#endif
        -:  112:
        -:  113:template <class _Tp>
        -:  114:inline _LIBCPP_INLINE_VISIBILITY
        -:  115:__autoreleasing _Tp*
        -:  116:addressof(__autoreleasing _Tp& __x) _NOEXCEPT
        -:  117:{
        -:  118:  return &__x;
        -:  119:}
        -:  120:
        -:  121:template <class _Tp>
        -:  122:inline _LIBCPP_INLINE_VISIBILITY
        -:  123:__unsafe_unretained _Tp*
        -:  124:addressof(__unsafe_unretained _Tp& __x) _NOEXCEPT
        -:  125:{
        -:  126:  return &__x;
        -:  127:}
        -:  128:#endif
        -:  129:
        -:  130:
        -:  131:// __weak_result_type
        -:  132:
        -:  133:template <class _Tp>
        -:  134:struct __derives_from_unary_function
        -:  135:{
        -:  136:private:
        -:  137:    struct __two {char __lx; char __lxx;};
        -:  138:    static __two __test(...);
        -:  139:    template <class _Ap, class _Rp>
        -:  140:        static unary_function<_Ap, _Rp>
        -:  141:        __test(const volatile unary_function<_Ap, _Rp>*);
        -:  142:public:
        -:  143:    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
        -:  144:    typedef decltype(__test((_Tp*)0)) type;
        -:  145:};
        -:  146:
        -:  147:template <class _Tp>
        -:  148:struct __derives_from_binary_function
        -:  149:{
        -:  150:private:
        -:  151:    struct __two {char __lx; char __lxx;};
        -:  152:    static __two __test(...);
        -:  153:    template <class _A1, class _A2, class _Rp>
        -:  154:        static binary_function<_A1, _A2, _Rp>
        -:  155:        __test(const volatile binary_function<_A1, _A2, _Rp>*);
        -:  156:public:
        -:  157:    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
        -:  158:    typedef decltype(__test((_Tp*)0)) type;
        -:  159:};
        -:  160:
        -:  161:template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
        -:  162:struct __maybe_derive_from_unary_function  // bool is true
        -:  163:    : public __derives_from_unary_function<_Tp>::type
        -:  164:{
        -:  165:};
        -:  166:
        -:  167:template <class _Tp>
        -:  168:struct __maybe_derive_from_unary_function<_Tp, false>
        -:  169:{
        -:  170:};
        -:  171:
        -:  172:template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
        -:  173:struct __maybe_derive_from_binary_function  // bool is true
        -:  174:    : public __derives_from_binary_function<_Tp>::type
        -:  175:{
        -:  176:};
        -:  177:
        -:  178:template <class _Tp>
        -:  179:struct __maybe_derive_from_binary_function<_Tp, false>
        -:  180:{
        -:  181:};
        -:  182:
        -:  183:template <class _Tp, bool = __has_result_type<_Tp>::value>
        -:  184:struct __weak_result_type_imp // bool is true
        -:  185:    : public __maybe_derive_from_unary_function<_Tp>,
        -:  186:      public __maybe_derive_from_binary_function<_Tp>
        -:  187:{
        -:  188:    typedef typename _Tp::result_type result_type;
        -:  189:};
        -:  190:
        -:  191:template <class _Tp>
        -:  192:struct __weak_result_type_imp<_Tp, false>
        -:  193:    : public __maybe_derive_from_unary_function<_Tp>,
        -:  194:      public __maybe_derive_from_binary_function<_Tp>
        -:  195:{
        -:  196:};
        -:  197:
        -:  198:template <class _Tp>
        -:  199:struct __weak_result_type
        -:  200:    : public __weak_result_type_imp<_Tp>
        -:  201:{
        -:  202:};
        -:  203:
        -:  204:// 0 argument case
        -:  205:
        -:  206:template <class _Rp>
        -:  207:struct __weak_result_type<_Rp ()>
        -:  208:{
        -:  209:    typedef _Rp result_type;
        -:  210:};
        -:  211:
        -:  212:template <class _Rp>
        -:  213:struct __weak_result_type<_Rp (&)()>
        -:  214:{
        -:  215:    typedef _Rp result_type;
        -:  216:};
        -:  217:
        -:  218:template <class _Rp>
        -:  219:struct __weak_result_type<_Rp (*)()>
        -:  220:{
        -:  221:    typedef _Rp result_type;
        -:  222:};
        -:  223:
        -:  224:// 1 argument case
        -:  225:
        -:  226:template <class _Rp, class _A1>
        -:  227:struct __weak_result_type<_Rp (_A1)>
        -:  228:    : public unary_function<_A1, _Rp>
        -:  229:{
        -:  230:};
        -:  231:
        -:  232:template <class _Rp, class _A1>
        -:  233:struct __weak_result_type<_Rp (&)(_A1)>
        -:  234:    : public unary_function<_A1, _Rp>
        -:  235:{
        -:  236:};
        -:  237:
        -:  238:template <class _Rp, class _A1>
        -:  239:struct __weak_result_type<_Rp (*)(_A1)>
        -:  240:    : public unary_function<_A1, _Rp>
        -:  241:{
        -:  242:};
        -:  243:
        -:  244:template <class _Rp, class _Cp>
        -:  245:struct __weak_result_type<_Rp (_Cp::*)()>
        -:  246:    : public unary_function<_Cp*, _Rp>
        -:  247:{
        -:  248:};
        -:  249:
        -:  250:template <class _Rp, class _Cp>
        -:  251:struct __weak_result_type<_Rp (_Cp::*)() const>
        -:  252:    : public unary_function<const _Cp*, _Rp>
        -:  253:{
        -:  254:};
        -:  255:
        -:  256:template <class _Rp, class _Cp>
        -:  257:struct __weak_result_type<_Rp (_Cp::*)() volatile>
        -:  258:    : public unary_function<volatile _Cp*, _Rp>
        -:  259:{
        -:  260:};
        -:  261:
        -:  262:template <class _Rp, class _Cp>
        -:  263:struct __weak_result_type<_Rp (_Cp::*)() const volatile>
        -:  264:    : public unary_function<const volatile _Cp*, _Rp>
        -:  265:{
        -:  266:};
        -:  267:
        -:  268:// 2 argument case
        -:  269:
        -:  270:template <class _Rp, class _A1, class _A2>
        -:  271:struct __weak_result_type<_Rp (_A1, _A2)>
        -:  272:    : public binary_function<_A1, _A2, _Rp>
        -:  273:{
        -:  274:};
        -:  275:
        -:  276:template <class _Rp, class _A1, class _A2>
        -:  277:struct __weak_result_type<_Rp (*)(_A1, _A2)>
        -:  278:    : public binary_function<_A1, _A2, _Rp>
        -:  279:{
        -:  280:};
        -:  281:
        -:  282:template <class _Rp, class _A1, class _A2>
        -:  283:struct __weak_result_type<_Rp (&)(_A1, _A2)>
        -:  284:    : public binary_function<_A1, _A2, _Rp>
        -:  285:{
        -:  286:};
        -:  287:
        -:  288:template <class _Rp, class _Cp, class _A1>
        -:  289:struct __weak_result_type<_Rp (_Cp::*)(_A1)>
        -:  290:    : public binary_function<_Cp*, _A1, _Rp>
        -:  291:{
        -:  292:};
        -:  293:
        -:  294:template <class _Rp, class _Cp, class _A1>
        -:  295:struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
        -:  296:    : public binary_function<const _Cp*, _A1, _Rp>
        -:  297:{
        -:  298:};
        -:  299:
        -:  300:template <class _Rp, class _Cp, class _A1>
        -:  301:struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
        -:  302:    : public binary_function<volatile _Cp*, _A1, _Rp>
        -:  303:{
        -:  304:};
        -:  305:
        -:  306:template <class _Rp, class _Cp, class _A1>
        -:  307:struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
        -:  308:    : public binary_function<const volatile _Cp*, _A1, _Rp>
        -:  309:{
        -:  310:};
        -:  311:
        -:  312:
        -:  313:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -:  314:// 3 or more arguments
        -:  315:
        -:  316:template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
        -:  317:struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
        -:  318:{
        -:  319:    typedef _Rp result_type;
        -:  320:};
        -:  321:
        -:  322:template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
        -:  323:struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
        -:  324:{
        -:  325:    typedef _Rp result_type;
        -:  326:};
        -:  327:
        -:  328:template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
        -:  329:struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
        -:  330:{
        -:  331:    typedef _Rp result_type;
        -:  332:};
        -:  333:
        -:  334:template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
        -:  335:struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
        -:  336:{
        -:  337:    typedef _Rp result_type;
        -:  338:};
        -:  339:
        -:  340:template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
        -:  341:struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
        -:  342:{
        -:  343:    typedef _Rp result_type;
        -:  344:};
        -:  345:
        -:  346:template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
        -:  347:struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
        -:  348:{
        -:  349:    typedef _Rp result_type;
        -:  350:};
        -:  351:
        -:  352:template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
        -:  353:struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
        -:  354:{
        -:  355:    typedef _Rp result_type;
        -:  356:};
        -:  357:
        -:  358:#endif // _LIBCPP_HAS_NO_VARIADICS
        -:  359:
        -:  360:// __invoke
        -:  361:
        -:  362:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -:  363:
        -:  364:// bullets 1 and 2
        -:  365:
        -:  366:template <class _Fp, class _A0, class ..._Args,
        -:  367:            class>
        -:  368:inline _LIBCPP_INLINE_VISIBILITY
        -:  369:auto
        -:  370:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -:  371:    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))
        -:  372:{
        -:  373:    return (_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...);
        -:  374:}
        -:  375:
        -:  376:template <class _Fp, class _A0, class ..._Args,
        -:  377:            class>
        -:  378:inline _LIBCPP_INLINE_VISIBILITY
        -:  379:auto
        -:  380:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -:  381:    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))
        -:  382:{
        -:  383:    return ((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...);
        -:  384:}
        -:  385:
        -:  386:// bullets 3 and 4
        -:  387:
        -:  388:template <class _Fp, class _A0,
        -:  389:            class>
        -:  390:inline _LIBCPP_INLINE_VISIBILITY
        -:  391:auto
        -:  392:__invoke(_Fp&& __f, _A0&& __a0)
        -:  393:    -> decltype(_VSTD::forward<_A0>(__a0).*__f)
        -:  394:{
        -:  395:    return _VSTD::forward<_A0>(__a0).*__f;
        -:  396:}
        -:  397:
        -:  398:template <class _Fp, class _A0,
        -:  399:            class>
        -:  400:inline _LIBCPP_INLINE_VISIBILITY
        -:  401:auto
        -:  402:__invoke(_Fp&& __f, _A0&& __a0)
        -:  403:    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f)
        -:  404:{
        -:  405:    return (*_VSTD::forward<_A0>(__a0)).*__f;
        -:  406:}
        -:  407:
        -:  408:// bullet 5
        -:  409:
        -:  410:template <class _Fp, class ..._Args>
        -:  411:inline _LIBCPP_INLINE_VISIBILITY
        -:  412:auto
        -:  413:__invoke(_Fp&& __f, _Args&& ...__args)
        -:  414:    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))
        -:  415:{
        -:  416:    return _VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...);
        -:  417:}
        -:  418:template <class _Tp, class ..._Args>
        -:  419:struct __invoke_return
        -:  420:{
        -:  421:    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;
        -:  422:};
        -:  423:
        -:  424:#else // _LIBCPP_HAS_NO_VARIADICS
        -:  425:
        -:  426:#include <__functional_base_03>
        -:  427:
        -:  428:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -:  429:
        -:  430:
        -:  431:template <class _Ret>
        -:  432:struct __invoke_void_return_wrapper
        -:  433:{
        -:  434:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -:  435:    template <class ..._Args>
        -:  436:    static _Ret __call(_Args&&... __args) {
        -:  437:        return __invoke(_VSTD::forward<_Args>(__args)...);
        -:  438:    }
        -:  439:#else
        -:  440:    template <class _Fn>
        -:  441:    static _Ret __call(_Fn __f) {
        -:  442:        return __invoke(__f);
        -:  443:    }
        -:  444:
        -:  445:    template <class _Fn, class _A0>
        -:  446:    static _Ret __call(_Fn __f, _A0& __a0) {
        -:  447:        return __invoke(__f, __a0);
        -:  448:    }
        -:  449:
        -:  450:    template <class _Fn, class _A0, class _A1>
        -:  451:    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1) {
        -:  452:        return __invoke(__f, __a0, __a1);
        -:  453:    }
        -:  454:
        -:  455:    template <class _Fn, class _A0, class _A1, class _A2>
        -:  456:    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2){
        -:  457:        return __invoke(__f, __a0, __a1, __a2);
        -:  458:    }
        -:  459:#endif
        -:  460:};
        -:  461:
        -:  462:template <>
        -:  463:struct __invoke_void_return_wrapper<void>
        -:  464:{
        -:  465:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -:  466:    template <class ..._Args>
        -:  467:    static void __call(_Args&&... __args) {
        -:  468:        __invoke(_VSTD::forward<_Args>(__args)...);
        -:  469:    }
        -:  470:#else
        -:  471:    template <class _Fn>
        -:  472:    static void __call(_Fn __f) {
        -:  473:        __invoke(__f);
        -:  474:    }
        -:  475:
        -:  476:    template <class _Fn, class _A0>
        -:  477:    static void __call(_Fn __f, _A0& __a0) {
        -:  478:        __invoke(__f, __a0);
        -:  479:    }
        -:  480:
        -:  481:    template <class _Fn, class _A0, class _A1>
        -:  482:    static void __call(_Fn __f, _A0& __a0, _A1& __a1) {
        -:  483:        __invoke(__f, __a0, __a1);
        -:  484:    }
        -:  485:
        -:  486:    template <class _Fn, class _A0, class _A1, class _A2>
        -:  487:    static void __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2) {
        -:  488:        __invoke(__f, __a0, __a1, __a2);
        -:  489:    }
        -:  490:#endif
        -:  491:};
        -:  492:
        -:  493:template <class _Tp>
        -:  494:class _LIBCPP_TYPE_VIS_ONLY reference_wrapper
        -:  495:    : public __weak_result_type<_Tp>
        -:  496:{
        -:  497:public:
        -:  498:    // types
        -:  499:    typedef _Tp type;
        -:  500:private:
        -:  501:    type* __f_;
        -:  502:
        -:  503:public:
        -:  504:    // construct/copy/destroy
        -:  505:    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT
        -:  506:        : __f_(_VSTD::addressof(__f)) {}
        -:  507:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  508:    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps
        -:  509:#endif
        -:  510:
        -:  511:    // access
        -:  512:    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}
        -:  513:    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}
        -:  514:
        -:  515:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -:  516:    // invoke
        -:  517:    template <class... _ArgTypes>
        -:  518:       _LIBCPP_INLINE_VISIBILITY
        -:  519:       typename __invoke_of<type&, _ArgTypes...>::type
        -:  520:          operator() (_ArgTypes&&... __args) const
        -:  521:          {
        -:  522:              return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);
        -:  523:          }
        -:  524:#else
        -:  525:
        -:  526:    _LIBCPP_INLINE_VISIBILITY
        -:  527:    typename __invoke_return<type>::type
        -:  528:       operator() () const
        -:  529:       {
        -:  530:           return __invoke(get());
        -:  531:       }
        -:  532:
        -:  533:    template <class _A0>
        -:  534:       _LIBCPP_INLINE_VISIBILITY
        -:  535:       typename __invoke_return0<type&, _A0>::type
        -:  536:          operator() (_A0& __a0) const
        -:  537:          {
        -:  538:              return __invoke<type&, _A0>(get(), __a0);
        -:  539:          }
        -:  540:
        -:  541:    template <class _A0, class _A1>
        -:  542:       _LIBCPP_INLINE_VISIBILITY
        -:  543:       typename __invoke_return1<type&, _A0, _A1>::type
        -:  544:          operator() (_A0& __a0, _A1& __a1) const
        -:  545:          {
        -:  546:              return __invoke<type&, _A0, _A1>(get(), __a0, __a1);
        -:  547:          }
        -:  548:
        -:  549:    template <class _A0, class _A1, class _A2>
        -:  550:       _LIBCPP_INLINE_VISIBILITY
        -:  551:       typename __invoke_return2<type&, _A0, _A1, _A2>::type
        -:  552:          operator() (_A0& __a0, _A1& __a1, _A2& __a2) const
        -:  553:          {
        -:  554:              return __invoke<type&, _A0, _A1, _A2>(get(), __a0, __a1, __a2);
        -:  555:          }
        -:  556:#endif // _LIBCPP_HAS_NO_VARIADICS
        -:  557:};
        -:  558:
        -:  559:template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
        -:  560:template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
        -:  561:template <class _Tp> struct __is_reference_wrapper
        -:  562:    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};
        -:  563:
        -:  564:template <class _Tp>
        -:  565:inline _LIBCPP_INLINE_VISIBILITY
        -:  566:reference_wrapper<_Tp>
        -:  567:ref(_Tp& __t) _NOEXCEPT
        -:  568:{
        -:  569:    return reference_wrapper<_Tp>(__t);
        -:  570:}
        -:  571:
        -:  572:template <class _Tp>
        -:  573:inline _LIBCPP_INLINE_VISIBILITY
        -:  574:reference_wrapper<_Tp>
        -:  575:ref(reference_wrapper<_Tp> __t) _NOEXCEPT
        -:  576:{
        -:  577:    return ref(__t.get());
        -:  578:}
        -:  579:
        -:  580:template <class _Tp>
        -:  581:inline _LIBCPP_INLINE_VISIBILITY
        -:  582:reference_wrapper<const _Tp>
        -:  583:cref(const _Tp& __t) _NOEXCEPT
        -:  584:{
        -:  585:    return reference_wrapper<const _Tp>(__t);
        -:  586:}
        -:  587:
        -:  588:template <class _Tp>
        -:  589:inline _LIBCPP_INLINE_VISIBILITY
        -:  590:reference_wrapper<const _Tp>
        -:  591:cref(reference_wrapper<_Tp> __t) _NOEXCEPT
        -:  592:{
        -:  593:    return cref(__t.get());
        -:  594:}
        -:  595:
        -:  596:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -:  597:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  598:#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
        -:  599:
        -:  600:template <class _Tp> void ref(const _Tp&&) = delete;
        -:  601:template <class _Tp> void cref(const _Tp&&) = delete;
        -:  602:
        -:  603:#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
        -:  604:
        -:  605:template <class _Tp> void ref(const _Tp&&);// = delete;
        -:  606:template <class _Tp> void cref(const _Tp&&);// = delete;
        -:  607:
        -:  608:#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
        -:  609:
        -:  610:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  611:
        -:  612:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -:  613:
        -:  614:#if _LIBCPP_STD_VER > 11
        -:  615:template <class _Tp1, class _Tp2 = void>
        -:  616:struct __is_transparent
        -:  617:{
        -:  618:private:
        -:  619:    struct __two {char __lx; char __lxx;};
        -:  620:    template <class _Up> static __two __test(...);
        -:  621:    template <class _Up> static char __test(typename _Up::is_transparent* = 0);
        -:  622:public:
        -:  623:    static const bool value = sizeof(__test<_Tp1>(0)) == 1;
        -:  624:};
        -:  625:#endif
        -:  626:
        -:  627:// allocator_arg_t
        -:  628:
        -:  629:struct _LIBCPP_TYPE_VIS_ONLY allocator_arg_t { };
        -:  630:
        -:  631:#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)
        -:  632:extern const allocator_arg_t allocator_arg;
        -:  633:#else
        -:  634:constexpr allocator_arg_t allocator_arg = allocator_arg_t();
        -:  635:#endif
        -:  636:
        -:  637:// uses_allocator
        -:  638:
        -:  639:template <class _Tp>
        -:  640:struct __has_allocator_type
        -:  641:{
        -:  642:private:
        -:  643:    struct __two {char __lx; char __lxx;};
        -:  644:    template <class _Up> static __two __test(...);
        -:  645:    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
        -:  646:public:
        -:  647:    static const bool value = sizeof(__test<_Tp>(0)) == 1;
        -:  648:};
        -:  649:
        -:  650:template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
        -:  651:struct __uses_allocator
        -:  652:    : public integral_constant<bool,
        -:  653:        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
        -:  654:{
        -:  655:};
        -:  656:
        -:  657:template <class _Tp, class _Alloc>
        -:  658:struct __uses_allocator<_Tp, _Alloc, false>
        -:  659:    : public false_type
        -:  660:{
        -:  661:};
        -:  662:
        -:  663:template <class _Tp, class _Alloc>
        -:  664:struct _LIBCPP_TYPE_VIS_ONLY uses_allocator
        -:  665:    : public __uses_allocator<_Tp, _Alloc>
        -:  666:{
        -:  667:};
        -:  668:
        -:  669:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -:  670:
        -:  671:// allocator construction
        -:  672:
        -:  673:template <class _Tp, class _Alloc, class ..._Args>
        -:  674:struct __uses_alloc_ctor_imp
        -:  675:{
        -:  676:    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;
        -:  677:    static const bool __ic =
        -:  678:        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
        -:  679:    static const int value = __ua ? 2 - __ic : 0;
        -:  680:};
        -:  681:
        -:  682:template <class _Tp, class _Alloc, class ..._Args>
        -:  683:struct __uses_alloc_ctor
        -:  684:    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
        -:  685:    {};
        -:  686:
        -:  687:template <class _Tp, class _Allocator, class... _Args>
        -:  688:inline _LIBCPP_INLINE_VISIBILITY
        -:  689:void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
        -:  690:{
        -:  691:    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);
        -:  692:}
        -:  693:
        -:  694:template <class _Tp, class _Allocator, class... _Args>
        -:  695:inline _LIBCPP_INLINE_VISIBILITY
        -:  696:void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
        -:  697:{
        -:  698:    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);
        -:  699:}
        -:  700:
        -:  701:template <class _Tp, class _Allocator, class... _Args>
        -:  702:inline _LIBCPP_INLINE_VISIBILITY
        -:  703:void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
        -:  704:{
        -:  705:    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);
        -:  706:}
        -:  707:
        -:  708:template <class _Tp, class _Allocator, class... _Args>
        -:  709:inline _LIBCPP_INLINE_VISIBILITY
        -:  710:void __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)
        -:  711:{ 
        -:  712:    __user_alloc_construct_impl( 
        -:  713:             __uses_alloc_ctor<_Tp, _Allocator>(), 
        -:  714:             __storage, __a, _VSTD::forward<_Args>(__args)...
        -:  715:        );
        -:  716:}
        -:  717:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -:  718:
        -:  719:_LIBCPP_END_NAMESPACE_STD
        -:  720:
        -:  721:#endif  // _LIBCPP_FUNCTIONAL_BASE
